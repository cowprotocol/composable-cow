{"language":"Solidity","sources":{"src/types/PerpetualStableSwap.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport {\n    IERC20,\n    GPv2Order,\n    IConditionalOrder,\n    IConditionalOrderGenerator,\n    BaseConditionalOrder\n} from \"../BaseConditionalOrder.sol\";\nimport {ConditionalOrdersUtilsLib as Utils} from \"./ConditionalOrdersUtilsLib.sol\";\n\n// --- error strings\n/// @dev The sell amount is insufficient (ie. not funded).\nstring constant NOT_FUNDED = \"not funded\";\n\n/**\n * @title A smart contract that is always willing to trade between tokenA and tokenB 1:1,\n * taking decimals into account (and adding specifiable spread)\n */\ncontract PerpetualStableSwap is BaseConditionalOrder {\n    /**\n     * Creates a new perpetual swap order. All resulting swaps will be made from the target contract.\n     * @param tokenA One of the two tokens that can be perpetually swapped against one another\n     * @param tokenB The other of the two tokens that can be perpetually swapped against one another\n     * @param validityBucketSeconds The width of the validity bucket in seconds\n     * @param halfSpreadBps The markup to parity (ie 1:1 exchange rate) that is charged for each swap\n     * @param appData Arbitrary data that will be passed to the app when the order is settled\n     */\n    struct Data {\n        IERC20 tokenA;\n        IERC20 tokenB;\n        // don't include a receiver as it will always be self (ie. owner of this order)\n        uint32 validityBucketSeconds;\n        uint256 halfSpreadBps;\n        bytes32 appData;\n    }\n\n    struct BuySellData {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        uint256 sellAmount;\n        uint256 buyAmount;\n    }\n\n    /**\n     * @inheritdoc IConditionalOrderGenerator\n     */\n    function getTradeableOrder(address owner, address, bytes32, bytes calldata staticInput, bytes calldata)\n        public\n        view\n        override\n        returns (GPv2Order.Data memory order)\n    {\n        /// @dev Decode the payload into the perpetual stable swap parameters.\n        PerpetualStableSwap.Data memory data = abi.decode(staticInput, (Data));\n\n        // Always sell whatever of the two tokens we have more of\n        BuySellData memory buySellData = side(owner, data);\n\n        // Make sure the order is funded, otherwise it is not valid\n        if (!(buySellData.sellAmount > 0)) {\n            revert IConditionalOrder.OrderNotValid(NOT_FUNDED);\n        }\n\n        // Unless spread is 0 (and there is no surplus), order collision is not an issue as sell and buy amounts should\n        // increase for each subsequent order. We therefore set validity to a large time span\n        // Note, that reducing current block to a common start time is needed so that the order returned here\n        // does not change between the time it is queried and the time it is settled. Validity should be between 1 & 2 weeks.\n        order = GPv2Order.Data(\n            buySellData.sellToken,\n            buySellData.buyToken,\n            address(0), // special case to refer to 'self' as the receiver per `GPv2Order.sol` library.\n            buySellData.sellAmount,\n            buySellData.buyAmount,\n            Utils.validToBucket(data.validityBucketSeconds),\n            data.appData,\n            0,\n            GPv2Order.KIND_SELL,\n            false,\n            GPv2Order.BALANCE_ERC20,\n            GPv2Order.BALANCE_ERC20\n        );\n    }\n\n    function side(address owner, PerpetualStableSwap.Data memory data)\n        internal\n        view\n        returns (BuySellData memory buySellData)\n    {\n        IERC20 tokenA = IERC20(address(data.tokenA));\n        IERC20 tokenB = IERC20(address(data.tokenB));\n        uint256 balanceA = tokenA.balanceOf(owner);\n        uint256 balanceB = tokenB.balanceOf(owner);\n\n        if (convertAmount(tokenA, balanceA, tokenB) > balanceB) {\n            buySellData = BuySellData({\n                sellToken: tokenA,\n                buyToken: tokenB,\n                sellAmount: balanceA,\n                buyAmount: convertAmount(tokenA, balanceA, tokenB) * (Utils.MAX_BPS + data.halfSpreadBps) / Utils.MAX_BPS\n            });\n        } else {\n            buySellData = BuySellData({\n                sellToken: tokenB,\n                buyToken: tokenA,\n                sellAmount: balanceB,\n                buyAmount: convertAmount(tokenB, balanceB, tokenA) * (Utils.MAX_BPS + data.halfSpreadBps) / Utils.MAX_BPS\n            });\n        }\n    }\n\n    function convertAmount(IERC20 srcToken, uint256 srcAmount, IERC20 destToken)\n        internal\n        view\n        returns (uint256 destAmount)\n    {\n        uint8 srcDecimals = srcToken.decimals();\n        uint8 destDecimals = destToken.decimals();\n\n        if (srcDecimals > destDecimals) {\n            destAmount = srcAmount / (10 ** (srcDecimals - destDecimals));\n        } else {\n            destAmount = srcAmount * (10 ** (destDecimals - srcDecimals));\n        }\n    }\n}\n"},"src/BaseConditionalOrder.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport {GPv2Order, IERC20} from \"cowprotocol/contracts/libraries/GPv2Order.sol\";\n\nimport {IERC165, IConditionalOrder, IConditionalOrderGenerator} from \"./interfaces/IConditionalOrder.sol\";\n\n// --- error strings\n/// @dev This error is returned by the `verify` function if the *generated* order hash does not match\n///      the hash passed as a parameter.\nstring constant INVALID_HASH = \"invalid hash\";\n\n/**\n * @title Base logic for conditional orders.\n * @dev Enforces the order verification logic for conditional orders, allowing developers\n *      to focus on the logic for generating the tradeable order.\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nabstract contract BaseConditionalOrder is IConditionalOrderGenerator {\n    /**\n     * @inheritdoc IConditionalOrder\n     * @dev As an order generator, the `GPv2Order.Data` passed as a parameter is ignored / not validated.\n     */\n    function verify(\n        address owner,\n        address sender,\n        bytes32 _hash,\n        bytes32 domainSeparator,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput,\n        GPv2Order.Data calldata\n    ) external view override {\n        GPv2Order.Data memory generatedOrder = getTradeableOrder(owner, sender, ctx, staticInput, offchainInput);\n\n        /// @dev Verify that the *generated* order is valid and matches the payload.\n        if (!(_hash == GPv2Order.hash(generatedOrder, domainSeparator))) {\n            revert IConditionalOrder.OrderNotValid(INVALID_HASH);\n        }\n    }\n\n    /**\n     * @dev Set the visibility of this function to `public` to allow `verify` to call it.\n     * @inheritdoc IConditionalOrderGenerator\n     */\n    function getTradeableOrder(\n        address owner,\n        address sender,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput\n    ) public view virtual override returns (GPv2Order.Data memory);\n\n    /**\n     * @inheritdoc IERC165\n     */\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\n        return interfaceId == type(IConditionalOrderGenerator).interfaceId || interfaceId == type(IERC165).interfaceId;\n    }\n}\n"},"src/types/ConditionalOrdersUtilsLib.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * @title ConditionalOrdersUtilsLib - Utility functions for standardising conditional orders.\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\nlibrary ConditionalOrdersUtilsLib {\n    uint256 constant MAX_BPS = 10000;\n\n    /**\n     * Given the width of the validity bucket, return the timestamp of the *end* of the bucket.\n     * @param validity The width of the validity bucket in seconds.\n     */\n    function validToBucket(uint32 validity) internal view returns (uint32 validTo) {\n        validTo = ((uint32(block.timestamp) / validity) * validity) + validity;\n    }\n\n    /**\n     * Given a price returned by a chainlink-like oracle, scale it to the desired amount of decimals\n     * @param oraclePrice return by a chainlink-like oracle\n     * @param fromDecimals the decimals the oracle returned (e.g. 8 for USDC)\n     * @param toDecimals the amount of decimals the price should be scaled to\n     */\n    function scalePrice(int256 oraclePrice, uint8 fromDecimals, uint8 toDecimals) internal pure returns (int256) {\n        if (fromDecimals < toDecimals) {\n            return oraclePrice * int256(10 ** uint256(toDecimals - fromDecimals));\n        } else if (fromDecimals > toDecimals) {\n            return oraclePrice / int256(10 ** uint256(fromDecimals - toDecimals));\n        }\n        return oraclePrice;\n    }\n}\n"},"lib/cowprotocol/src/contracts/libraries/GPv2Order.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\nimport \"../interfaces/IERC20.sol\";\n\n/// @title Gnosis Protocol v2 Order Library\n/// @author Gnosis Developers\nlibrary GPv2Order {\n    /// @dev The complete data for a Gnosis Protocol order. This struct contains\n    /// all order parameters that are signed for submitting to GP.\n    struct Data {\n        IERC20 sellToken;\n        IERC20 buyToken;\n        address receiver;\n        uint256 sellAmount;\n        uint256 buyAmount;\n        uint32 validTo;\n        bytes32 appData;\n        uint256 feeAmount;\n        bytes32 kind;\n        bool partiallyFillable;\n        bytes32 sellTokenBalance;\n        bytes32 buyTokenBalance;\n    }\n\n    /// @dev The order EIP-712 type hash for the [`GPv2Order.Data`] struct.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\n    ///     \"Order(\" +\n    ///         \"address sellToken,\" +\n    ///         \"address buyToken,\" +\n    ///         \"address receiver,\" +\n    ///         \"uint256 sellAmount,\" +\n    ///         \"uint256 buyAmount,\" +\n    ///         \"uint32 validTo,\" +\n    ///         \"bytes32 appData,\" +\n    ///         \"uint256 feeAmount,\" +\n    ///         \"string kind,\" +\n    ///         \"bool partiallyFillable,\" +\n    ///         \"string sellTokenBalance,\" +\n    ///         \"string buyTokenBalance\" +\n    ///     \")\"\n    /// )\n    /// ```\n    bytes32 internal constant TYPE_HASH =\n        hex\"d5a25ba2e97094ad7d83dc28a6572da797d6b3e7fc6663bd93efb789fc17e489\";\n\n    /// @dev The marker value for a sell order for computing the order struct\n    /// hash. This allows the EIP-712 compatible wallets to display a\n    /// descriptive string for the order kind (instead of 0 or 1).\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"sell\")\n    /// ```\n    bytes32 internal constant KIND_SELL =\n        hex\"f3b277728b3fee749481eb3e0b3b48980dbbab78658fc419025cb16eee346775\";\n\n    /// @dev The OrderKind marker value for a buy order for computing the order\n    /// struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"buy\")\n    /// ```\n    bytes32 internal constant KIND_BUY =\n        hex\"6ed88e868af0a1983e3886d5f3e95a2fafbd6c3450bc229e27342283dc429ccc\";\n\n    /// @dev The TokenBalance marker value for using direct ERC20 balances for\n    /// computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"erc20\")\n    /// ```\n    bytes32 internal constant BALANCE_ERC20 =\n        hex\"5a28e9363bb942b639270062aa6bb295f434bcdfc42c97267bf003f272060dc9\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault external\n    /// balances (in order to re-use Vault ERC20 approvals) for computing the\n    /// order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"external\")\n    /// ```\n    bytes32 internal constant BALANCE_EXTERNAL =\n        hex\"abee3b73373acd583a130924aad6dc38cfdc44ba0555ba94ce2ff63980ea0632\";\n\n    /// @dev The TokenBalance marker value for using Balancer Vault internal\n    /// balances for computing the order struct hash.\n    ///\n    /// This value is pre-computed from the following expression:\n    /// ```\n    /// keccak256(\"internal\")\n    /// ```\n    bytes32 internal constant BALANCE_INTERNAL =\n        hex\"4ac99ace14ee0a5ef932dc609df0943ab7ac16b7583634612f8dc35a4289a6ce\";\n\n    /// @dev Marker address used to indicate that the receiver of the trade\n    /// proceeds should the owner of the order.\n    ///\n    /// This is chosen to be `address(0)` for gas efficiency as it is expected\n    /// to be the most common case.\n    address internal constant RECEIVER_SAME_AS_OWNER = address(0);\n\n    /// @dev The byte length of an order unique identifier.\n    uint256 internal constant UID_LENGTH = 56;\n\n    /// @dev Returns the actual receiver for an order. This function checks\n    /// whether or not the [`receiver`] field uses the marker value to indicate\n    /// it is the same as the order owner.\n    ///\n    /// @return receiver The actual receiver of trade proceeds.\n    function actualReceiver(\n        Data memory order,\n        address owner\n    ) internal pure returns (address receiver) {\n        if (order.receiver == RECEIVER_SAME_AS_OWNER) {\n            receiver = owner;\n        } else {\n            receiver = order.receiver;\n        }\n    }\n\n    /// @dev Return the EIP-712 signing hash for the specified order.\n    ///\n    /// @param order The order to compute the EIP-712 signing hash for.\n    /// @param domainSeparator The EIP-712 domain separator to use.\n    /// @return orderDigest The 32 byte EIP-712 struct hash.\n    function hash(\n        Data memory order,\n        bytes32 domainSeparator\n    ) internal pure returns (bytes32 orderDigest) {\n        bytes32 structHash;\n\n        // NOTE: Compute the EIP-712 order struct hash in place. As suggested\n        // in the EIP proposal, noting that the order struct has 12 fields, and\n        // prefixing the type hash `(1 + 12) * 32 = 416` bytes to hash.\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#rationale-for-encodedata>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let dataStart := sub(order, 32)\n            let temp := mload(dataStart)\n            mstore(dataStart, TYPE_HASH)\n            structHash := keccak256(dataStart, 416)\n            mstore(dataStart, temp)\n        }\n\n        // NOTE: Now that we have the struct hash, compute the EIP-712 signing\n        // hash using scratch memory past the free memory pointer. The signing\n        // hash is computed from `\"\\x19\\x01\" || domainSeparator || structHash`.\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory>\n        // <https://github.com/ethereum/EIPs/blob/master/EIPS/eip-712.md#specification>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            mstore(freeMemoryPointer, \"\\x19\\x01\")\n            mstore(add(freeMemoryPointer, 2), domainSeparator)\n            mstore(add(freeMemoryPointer, 34), structHash)\n            orderDigest := keccak256(freeMemoryPointer, 66)\n        }\n    }\n\n    /// @dev Packs order UID parameters into the specified memory location. The\n    /// result is equivalent to `abi.encodePacked(...)` with the difference that\n    /// it allows re-using the memory for packing the order UID.\n    ///\n    /// This function reverts if the order UID buffer is not the correct size.\n    ///\n    /// @param orderUid The buffer pack the order UID parameters into.\n    /// @param orderDigest The EIP-712 struct digest derived from the order\n    /// parameters.\n    /// @param owner The address of the user who owns this order.\n    /// @param validTo The epoch time at which the order will stop being valid.\n    function packOrderUidParams(\n        bytes memory orderUid,\n        bytes32 orderDigest,\n        address owner,\n        uint32 validTo\n    ) internal pure {\n        require(orderUid.length == UID_LENGTH, \"GPv2: uid buffer overflow\");\n\n        // NOTE: Write the order UID to the allocated memory buffer. The order\n        // parameters are written to memory in **reverse order** as memory\n        // operations write 32-bytes at a time and we want to use a packed\n        // encoding. This means, for example, that after writing the value of\n        // `owner` to bytes `20:52`, writing the `orderDigest` to bytes `0:32`\n        // will **overwrite** bytes `20:32`. This is desirable as addresses are\n        // only 20 bytes and `20:32` should be `0`s:\n        //\n        //        |           1111111111222222222233333333334444444444555555\n        //   byte | 01234567890123456789012345678901234567890123456789012345\n        // -------+---------------------------------------------------------\n        //  field | [.........orderDigest..........][......owner.......][vT]\n        // -------+---------------------------------------------------------\n        // mstore |                         [000000000000000000000000000.vT]\n        //        |                     [00000000000.......owner.......]\n        //        | [.........orderDigest..........]\n        //\n        // Additionally, since Solidity `bytes memory` are length prefixed,\n        // 32 needs to be added to all the offsets.\n        //\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            mstore(add(orderUid, 56), validTo)\n            mstore(add(orderUid, 52), owner)\n            mstore(add(orderUid, 32), orderDigest)\n        }\n    }\n\n    /// @dev Extracts specific order information from the standardized unique\n    /// order id of the protocol.\n    ///\n    /// @param orderUid The unique identifier used to represent an order in\n    /// the protocol. This uid is the packed concatenation of the order digest,\n    /// the validTo order parameter and the address of the user who created the\n    /// order. It is used by the user to interface with the contract directly,\n    /// and not by calls that are triggered by the solvers.\n    /// @return orderDigest The EIP-712 signing digest derived from the order\n    /// parameters.\n    /// @return owner The address of the user who owns this order.\n    /// @return validTo The epoch time at which the order will stop being valid.\n    function extractOrderUidParams(\n        bytes calldata orderUid\n    )\n        internal\n        pure\n        returns (bytes32 orderDigest, address owner, uint32 validTo)\n    {\n        require(orderUid.length == UID_LENGTH, \"GPv2: invalid uid\");\n\n        // Use assembly to efficiently decode packed calldata.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            orderDigest := calldataload(orderUid.offset)\n            owner := shr(96, calldataload(add(orderUid.offset, 32)))\n            validTo := shr(224, calldataload(add(orderUid.offset, 52)))\n        }\n    }\n}\n"},"src/interfaces/IConditionalOrder.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport {GPv2Order} from \"cowprotocol/contracts/libraries/GPv2Order.sol\";\nimport {GPv2Interaction} from \"cowprotocol/contracts/libraries/GPv2Interaction.sol\";\nimport {IERC165} from \"safe/interfaces/IERC165.sol\";\n\n/**\n * @title Conditional Order Interface\n * @author CoW Protocol Developers + mfw78 <mfw78@rndlabs.xyz>\n */\ninterface IConditionalOrder {\n    \n    /// @dev This error is returned by the `getTradeableOrder` function if the order condition is not met.\n    ///      A parameter of `string` type is included to allow the caller to specify the reason for the failure.\n    error OrderNotValid(string);\n\n    // --- errors specific for polling\n    // Signal to a watch tower that polling should be attempted again.\n    error PollTryNextBlock(string reason);\n    // Signal to a watch tower that polling should be attempted again at a specific block number.\n    error PollTryAtBlock(uint256 blockNumber, string reason);\n    // Signal to a watch tower that polling should be attempted again at a specific epoch (unix timestamp).\n    error PollTryAtEpoch(uint256 timestamp, string reason);\n    // Signal to a watch tower that the conditional order should not be polled again (delete).\n    error PollNever(string reason);\n\n    /**\n     * @dev This struct is used to uniquely identify a conditional order for an owner.\n     *      H(handler || salt || staticInput) **MUST** be unique for an owner.\n     */\n    struct ConditionalOrderParams {\n        IConditionalOrder handler;\n        bytes32 salt;\n        bytes staticInput;\n    }\n\n    /**\n     * Verify if a given discrete order is valid.\n     * @dev Used in combination with `isValidSafeSignature` to verify that the order is signed by the Safe.\n     *      **MUST** revert if the order condition is not met.\n     * @dev The `order` parameter is ignored / not validated by the `IConditionalOrderGenerator` implementation.\n     *      This parameter is included to allow more granular control over the order verification logic, and to\n     *      allow a watch tower / user to propose a discrete order without it being generated by on-chain logic.\n     * @param owner the contract who is the owner of the order\n     * @param sender the `msg.sender` of the transaction\n     * @param _hash the hash of the order\n     * @param domainSeparator the domain separator used to sign the order\n     * @param ctx the context key of the order (bytes32(0) if a merkle tree is used, otherwise H(params)) with which to lookup the cabinet\n     * @param staticInput the static input for all discrete orders cut from this conditional order\n     * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order\n     * @param order `GPv2Order.Data` of a discrete order to be verified (if *not* an `IConditionalOrderGenerator`).\n     */\n    function verify(\n        address owner,\n        address sender,\n        bytes32 _hash,\n        bytes32 domainSeparator,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput,\n        GPv2Order.Data calldata order\n    ) external view;\n}\n\n/**\n * @title Conditional Order Generator Interface\n * @author mfw78 <mfw78@rndlabs.xyz>\n */\ninterface IConditionalOrderGenerator is IConditionalOrder, IERC165 {\n    /**\n     * @dev This event is emitted when a new conditional order is created.\n     * @param owner the address that has created the conditional order\n     * @param params the address / salt / data of the conditional order\n     */\n    event ConditionalOrderCreated(address indexed owner, IConditionalOrder.ConditionalOrderParams params);\n\n    /**\n     * @dev Get a tradeable order that can be posted to the CoW Protocol API and would pass signature validation.\n     *      **MUST** revert if the order condition is not met.\n     * @param owner the contract who is the owner of the order\n     * @param sender the `msg.sender` of the parent `isValidSignature` call\n     * @param ctx the context of the order (bytes32(0) if merkle tree is used, otherwise the H(params))\n     * @param staticInput the static input for all discrete orders cut from this conditional order\n     * @param offchainInput dynamic off-chain input for a discrete order cut from this conditional order\n     * @return the tradeable order for submission to the CoW Protocol API\n     */\n    function getTradeableOrder(\n        address owner,\n        address sender,\n        bytes32 ctx,\n        bytes calldata staticInput,\n        bytes calldata offchainInput\n    ) external view returns (GPv2Order.Data memory);\n}\n"},"lib/cowprotocol/src/contracts/interfaces/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n\n// Vendored from OpenZeppelin contracts with minor modifications:\n// - Modified Solidity version\n// - Formatted code\n// - Added `name`, `symbol` and `decimals` function declarations\n// <https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/token/ERC20/IERC20.sol>\n\npragma solidity >=0.7.6 <0.9.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the number of decimals the token uses.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"},"lib/cowprotocol/src/contracts/libraries/GPv2Interaction.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-or-later\npragma solidity >=0.7.6 <0.9.0;\n\n/// @title Gnosis Protocol v2 Interaction Library\n/// @author Gnosis Developers\nlibrary GPv2Interaction {\n    /// @dev Interaction data for performing arbitrary contract interactions.\n    /// Submitted to [`GPv2Settlement.settle`] for code execution.\n    struct Data {\n        address target;\n        uint256 value;\n        bytes callData;\n    }\n\n    /// @dev Execute an arbitrary contract interaction.\n    ///\n    /// @param interaction Interaction data.\n    function execute(Data calldata interaction) internal {\n        address target = interaction.target;\n        uint256 value = interaction.value;\n        bytes calldata callData = interaction.callData;\n\n        // NOTE: Use assembly to call the interaction instead of a low level\n        // call for two reasons:\n        // - We don't want to copy the return data, since we discard it for\n        // interactions.\n        // - Solidity will under certain conditions generate code to copy input\n        // calldata twice to memory (the second being a \"memcopy loop\").\n        // <https://github.com/gnosis/gp-v2-contracts/pull/417#issuecomment-775091258>\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            let freeMemoryPointer := mload(0x40)\n            calldatacopy(freeMemoryPointer, callData.offset, callData.length)\n            if iszero(\n                call(\n                    gas(),\n                    target,\n                    value,\n                    freeMemoryPointer,\n                    callData.length,\n                    0,\n                    0\n                )\n            ) {\n                returndatacopy(0, 0, returndatasize())\n                revert(0, returndatasize())\n            }\n        }\n    }\n\n    /// @dev Extracts the Solidity ABI selector for the specified interaction.\n    ///\n    /// @param interaction Interaction data.\n    /// @return result The 4 byte function selector of the call encoded in\n    /// this interaction.\n    function selector(\n        Data calldata interaction\n    ) internal pure returns (bytes4 result) {\n        bytes calldata callData = interaction.callData;\n        if (callData.length >= 4) {\n            // NOTE: Read the first word of the interaction's calldata. The\n            // value does not need to be shifted since `bytesN` values are left\n            // aligned, and the value does not need to be masked since masking\n            // occurs when the value is accessed and not stored:\n            // <https://docs.soliditylang.org/en/v0.7.6/abi-spec.html#encoding-of-indexed-event-parameters>\n            // <https://docs.soliditylang.org/en/v0.7.6/assembly.html#access-to-external-variables-functions-and-libraries>\n            // solhint-disable-next-line no-inline-assembly\n            assembly {\n                result := calldataload(callData.offset)\n            }\n        }\n    }\n}\n"},"lib/safe/contracts/interfaces/IERC165.sol":{"content":"// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by `interfaceId`.\n     * See the corresponding EIP section\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"}},"settings":{"remappings":["@openzeppelin/=lib/@openzeppelin/","ds-test/=lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/@openzeppelin/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","murky/=lib/murky/src/","openzeppelin-contracts/=lib/murky/lib/openzeppelin-contracts/","safe/=lib/safe/contracts/","cowprotocol/=lib/cowprotocol/src/","openzeppelin/=lib/@openzeppelin/contracts/"],"optimizer":{"enabled":true,"runs":20000},"modelChecker":{"contracts":{"/workspaces/composable-cow/src/types/twap/libraries/TWAPOrderMathLib.sol":["TWAPOrderMathLib"]},"engine":"chc","timeout":100000,"targets":["assert","underflow","overflow","divByZero","constantCondition","popEmptyArray","outOfBounds","balance"]},"metadata":{"useLiteralContent":false,"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":false,"libraries":{}}}
